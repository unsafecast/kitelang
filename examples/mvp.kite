// This example does NOT compile, it is just an example of what I want the minimum viable product to be

// This adds the file to the compilation and brings the definitions into the current context
open "std.kite"

// A struct with generics
struct dynamic_array(type)
{
	type* elements
	usize size
	usize allocated_size
	oninit usize element_size  // oninit means it needs to be set only at initialization
}

proc(type) make_dynamic_array(varargs) dynamic_array(type)
{
	// Struct initialization
	var arr = dynamic_array(type) {
		elements = std_alloc_bytes(std_c_allocator, sizeof(type) * varargs.size),
		size = 0,
		allocated_size = 1,
		element_size = sizeof(type),
	};

	// varargs is literally just an array
	for arg in varargs {
		push(ref arr, arg);
	}

	return arr;
}

// nothing == void in C
proc(type) push(dynamic_array(type)* arr, type val) nothing {
	if arr.size == arr.allocated_size {
		reserve(arr, 1);
	}

	arr.elements[arr.size] = val;
	arr.size += 1;
}

proc(type) reserve(dynamic_array(type)* arr, usize how_many) nothing {
	arr.allocated_size += how_many;
	arr.elements = std_realloc(std_c_allocator, arr.elements, arr.allocated_size * arr.element_size);
}

// the [x] operator calls nth
proc(type) nth(dynamic_array(type)* arr, usize index) type {
	if index >= arr.size {
		std_panic("index out of bounds");
	}

	return arr.elements[index];
}

proc main() {
	var numbers = make_dynamic_array(int32)(1, 2, 3);
	var second = numbers[1];
	var still_second = nth(ref numbers, 1);

	push(ref numbers, 42);
}
